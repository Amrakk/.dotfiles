#!/usr/bin/env bash
set -euo pipefail
set -o errtrace

notify() {
  if command -v notify-send >/dev/null 2>&1; then
    notify-send "Discord Updater" "$1"
  fi
}

print_stacktrace() {
  echo "Stack trace (most recent call last):" >&2
  local i=0
  while caller $i; do
    ((i++))
  done >&2
}

fail() {
  local exit_code=${1:-1}
  local lineno=${2:-0}
  local msg=${3:-"Fatal error"}
  notify "Discord Updater: ${msg} (code ${exit_code})"
  echo "ERROR: ${msg} (exit ${exit_code}) at line ${lineno}" >&2
  print_stacktrace
  exit "$exit_code"
}

_on_err() {
  local exit_code=$?
  local lineno=${BASH_LINENO[0]:-0}
  local cmd="${BASH_COMMAND:-<unknown>}"
  fail "$exit_code" "$lineno" "Unexpected error running: ${cmd}"
}
trap _on_err ERR

# --- locate build_info.json (Arch typical paths) ------------------------------
find_json() {
  local candidates=(
    "/usr/lib/discord/resources/build_info.json"
    "/usr/lib/discord-ptb/resources/build_info.json"
    "/usr/lib/discord-canary/resources/build_info.json"
    "/opt/discord/resources/build_info.json"
  )
  for f in "${candidates[@]}"; do [[ -f "$f" ]] && { echo "$f"; return 0; }; done
  mapfile -t found < <(find /usr /opt -type f -path "*/discord*/resources/build_info.json" 2>/dev/null || true)
  [[ ${#found[@]} -gt 0 ]] && { echo "${found[0]}"; return 0; }
  return 1
}

JSON="$(find_json || true)"
[[ -z "${JSON:-}" ]] && fail 1 0 "Could not locate build_info.json"

ROOT="${JSON%/resources/build_info.json}"

have() { command -v "$1" >/dev/null 2>&1; }

read_field() {
  local key="$1"
  if have jq; then
    jq -r --arg k "$key" '.[$k] // empty' "$JSON"
  else
    grep -oE "\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]+\"" "$JSON" \
      | head -1 | sed -E 's/.*"[[:space:]]*:[[:space:]]*"([^"]+)".*/\1/'
  fi
}

LOCAL_CHANNEL="$(read_field releaseChannel)"
LOCAL_VERSION="$(read_field version)"

norm_chan() {
  case "${1,,}" in
    stable|release|"") echo "stable" ;;
    ptb|public_test|public-test) echo "ptb" ;;
    canary|beta) echo "canary" ;;
    *) echo "stable" ;;
  esac
}
CHAN_FROM_FILE="$(norm_chan "${LOCAL_CHANNEL:-}")"
CHAN="${CHAN:-$CHAN_FROM_FILE}"

# --- upstream version resolution ----------------------------------------------
REMOTE_URL="$(curl -fsSLI -o /dev/null -w '%{url_effective}' \
  "https://discord.com/api/download/${CHAN}?platform=linux&format=tar.gz")" \
  || fail $? ${LINENO} "Failed resolving Discord upstream URL"

REMOTE_VER="$(printf '%s' "$REMOTE_URL" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)"
[[ -z "${REMOTE_VER:-}" ]] && fail 2 ${LINENO} "Unable to extract upstream version for channel=${CHAN}"

REMOTE_VER="${REMOTE_VER//$'\n'/}"
REMOTE_VER="${REMOTE_VER//$'\r'/}"

printf "JSON: %s\n" "$JSON"
printf "releaseChannel(local): %s  → channel: %s\n" "${LOCAL_CHANNEL:-<unset>}" "$CHAN"
printf "version(local): %s\n" "${LOCAL_VERSION:-<unset>}"
printf "version(upstream %s): %s\n" "$CHAN" "$REMOTE_VER"

# --- update build_info.json ---------------------------------------------------
if [[ "$LOCAL_VERSION" != "$REMOTE_VER" || -z "${LOCAL_VERSION:-}" ]]; then
  echo "Updating build_info.json → version=${REMOTE_VER}, releaseChannel=${CHAN}"
  mkdir -p "$HOME/.cache/discord-buildinfo/backups"
  cp -n "$JSON" "$HOME/.cache/discord-buildinfo/backups/build_info.json.bak.$(date +%s)" 2>/dev/null || true

  tmp="$(mktemp)" || fail 3 ${LINENO} "mktemp failed"
  if have jq; then
    jq --arg v "$REMOTE_VER" --arg ch "$CHAN" \
       '.version=$v | .releaseChannel=$ch' "$JSON" > "$tmp" \
       || fail 4 ${LINENO} "jq failed while writing new build_info.json"
  else
    printf '{\n  "releaseChannel": "%s",\n  "version": "%s"\n}\n' \
      "$CHAN" "$REMOTE_VER" > "$tmp" \
      || fail 5 ${LINENO} "Fallback JSON write failed"
  fi
  cat "$tmp" > "$JSON" || fail 6 ${LINENO} "Failed to overwrite build_info.json"
  rm -f "$tmp"
  notify "Discord updated to ${REMOTE_VER} (${CHAN})"
else
  echo "Local version already matches upstream."
fi

# --- LAUNCH real Electron binary (do NOT use exec so we can capture failures) ---
launch_binary_and_catch() {
  local bin="$1"
  shift
  echo "Launching: $bin $*"
  if [[ -x "$bin" ]]; then
    # run directly so we can inspect exit code and print stacktrace on failure
    "$bin" "$@" || fail $? ${LINENO} "Discord binary failed to start: ${bin}"
  else
    return 1
  fi
}

REAL_BIN="$ROOT/Discord"
if launch_binary_and_catch "$REAL_BIN" "$@"; then
  exit 0
fi

for cand in "/usr/lib/discord/Discord" "/usr/lib/discord-ptb/Discord" "/usr/lib/discord-canary/Discord"; do
  if launch_binary_and_catch "$cand" "$@"; then
    exit 0
  fi
done

fail 3 ${LINENO} "Could not find real Discord binary (expected ${ROOT}/Discord)"
